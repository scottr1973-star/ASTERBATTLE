<!-- FILE: spaceharrier_plus.html
     What you get in this build:
       • Ship: MUCH more maneuverable (bigger bounds + snappier response). Full -X/+X and -Y/+Y roaming.
       • Explosions: visual FX + **boom sounds** (no external files; pure WebAudio).
       • Lasers: already fixed—keep swept collision; explosions award points.
       • Cockpit: on-screen HUD & frame similar to your reference (arched frame, red reticle, cyan panels).
       • Mobile: left joystick + right round fire buttons; optional phone tilt. 
       • Splash: bulletproof—overlay removed from DOM on start, donation links still work. -->
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Neon Star Run — Plus</title>
<style>
  :root{ --fg:#e6f1ff; --bg0:#060910; --bg1:#0b1530; --accent:#00f6ff; --hud:#00e0ff; --ret:#ff4055; }
  html,body{
    height:100%;margin:0;background:
      radial-gradient(1200px 800px at 75% 15%,rgba(0,246,255,.08),transparent 60%),
      radial-gradient(1000px 700px at 20% 85%,rgba(255,109,240,.08),transparent 60%),
      linear-gradient(180deg,var(--bg1),var(--bg0));
    color:var(--fg);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    overscroll-behavior:none; touch-action:none;
  }
  #host{position:fixed;inset:0;overflow:hidden}
  canvas{display:block;width:100%;height:100%;touch-action:none}

  /* HUD / text pills */
  #hudTop{position:absolute;left:12px;top:12px;display:flex;gap:10px;z-index:60;pointer-events:none}
  .pill{background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 10px;font-weight:800;backdrop-filter:blur(3px)}
  #hint{position:absolute;left:50%;bottom:10px;transform:translateX(-50%);opacity:.75;font-size:12px;z-index:60;pointer-events:none}

  #topBtns{position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:60}
  .btn{appearance:none;border:0;border-radius:12px;padding:8px 12px;background:rgba(255,255,255,.1);color:var(--fg);font-weight:800;cursor:pointer;backdrop-filter:blur(3px)}
  .btn:active{transform:scale(.98)}

  /* Splash */
  .overlay{position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);z-index:100}
  .card{background:linear-gradient(180deg,rgba(255,255,255,.07),rgba(255,255,255,.04));border:1px solid rgba(255,255,255,.12);
        border-radius:16px;padding:20px 24px;text-align:center;max-width:560px}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}

  /* Mobile controls */
  #mobileControls{position:absolute;inset:0;pointer-events:none;z-index:70}
  #joypad{
    position:absolute; left:4px; bottom:12px; width:38vw; max-width:260px; aspect-ratio:1/1; pointer-events:auto;
    background:rgba(255,255,255,.05); border:1px dashed rgba(255,255,255,.18); border-radius:16px
  }
  .stickBase{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:46%;aspect-ratio:1/1;border-radius:50%;
             background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.2)}
  .stickKnob{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:28%;aspect-ratio:1/1;border-radius:50%;
             background:radial-gradient(circle at 35% 35%,rgba(255,255,255,.7),rgba(255,255,255,.1));border:1px solid rgba(255,255,255,.35);box-shadow:0 2px 10px rgba(0,0,0,.5)}
  #fireBtns{position:absolute;right:10px;bottom:10px;display:flex;flex-direction:column;gap:10px;pointer-events:auto}
  .fire{
    width:64px;height:64px;min-width:0;padding:0;border-radius:999px;border:0;font-weight:900;font-size:10px;letter-spacing:.6px;color:#081017;
    display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(0,0,0,.35)
  }
  #btnLaser{background:linear-gradient(180deg,#82fff4,#00f0ff)}
  #btnMissile{background:linear-gradient(180deg,#ffd35a,#ff9e3d)}
  #tiltChip{position:absolute;left:50%;bottom:76px;transform:translateX(-50%);padding:6px 10px;border-radius:999px;
            background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.15);font-weight:700;z-index:70}

  /* Reticle (red) */
  #reticle{position:absolute;left:50%;top:50%;width:28px;height:28px;transform:translate(-50%,-50%);z-index:65;pointer-events:none}
  #reticle:before,#reticle:after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);border:2px solid var(--ret);border-radius:50%;width:100%;height:100%;box-shadow:0 0 10px rgba(255,64,85,.35)}
  #reticle:after{width:4px;height:4px;background:var(--ret);border:0;border-radius:50%}

  /* Cockpit frame overlay (SVG) */
  #cockpit{position:absolute;inset:0;pointer-events:none;z-index:64}
  #cockpit svg{width:100%;height:100%}
  .ck-line{fill:none;stroke:var(--hud);stroke-width:3;opacity:.85;filter:drop-shadow(0 0 6px rgba(0,224,255,.6))}
  .ck-panel{position:absolute;bottom:12px;left:12px;right:12px;height:90px;border:2px solid var(--hud);border-radius:12px;
            background:linear-gradient(180deg,rgba(0,30,50,.45),rgba(0,10,18,.25));box-shadow:0 0 12px rgba(0,224,255,.25) inset;display:flex;gap:10px;padding:8px}
  .dial{flex:0 0 120px;border:2px solid var(--hud);border-radius:10px;display:flex;align-items:center;justify-content:center;font-weight:800;color:var(--hud)}
  .readout{flex:1;border:2px solid var(--hud);border-radius:10px;padding:6px;color:var(--hud);font-weight:800;display:flex;align-items:center;gap:14px;overflow:hidden}
  .tag{opacity:.8}

  /* Error box */
  #err{position:fixed;left:8px;bottom:8px;max-width:92%;background:#200;padding:8px 10px;color:#fbb;border:1px solid #a33;border-radius:8px;
       font:12px/1.3 monospace;display:none;z-index:99999;white-space:pre-wrap}
</style>
</head>
<body>
<div id="host">
  <canvas id="game"></canvas>

  <div id="hudTop">
    <div class="pill">Score: <span id="score">0</span></div>
    <div class="pill">Best: <span id="best">0</span></div>
    <div class="pill">HP: <span id="hp">100</span></div>
  </div>
  <div id="reticle"></div>

  <div id="topBtns">
    <button id="btnTilt" class="btn">Enable Tilt</button>
    <button id="btnPause" class="btn">Pause</button>
    <button id="btnFull" class="btn">Fullscreen</button>
  </div>

  <!-- Splash (removed from DOM on start) -->
  <div id="startOverlay" class="overlay" onclick="if(event.target===this) startGame(event)">
    <div id="startCard" class="card">
      <h1>Neon Star Run</h1>
      <p>Tap/click Start or the background to begin.</p>
      <div class="row" style="margin-top:10px">
        <button id="btnStart" class="btn" onclick="startGame(event)">Start</button>
        <a class="btn" href="https://paypal.me/YourLink" target="_blank" rel="noopener">Donate (PayPal)</a>
        <a class="btn" href="https://cash.app/$YourLink" target="_blank" rel="noopener">Donate (Cash App)</a>
        <a class="btn" href="https://venmo.com/u/YourLink" target="_blank" rel="noopener">Donate (Venmo)</a>
      </div>
      <p style="opacity:.75;font-size:12px;margin-top:8px">iOS: after starting, tap “Enable Tilt”.</p>
    </div>
  </div>

  <!-- Cockpit overlay -->
  <div id="cockpit">
    <svg viewBox="0 0 100 100" preserveAspectRatio="none">
      <!-- arch -->
      <path class="ck-line" d="M3,10 C18,2 82,2 97,10" />
      <!-- left brace -->
      <path class="ck-line" d="M6,12 L6,35" />
      <path class="ck-line" d="M6,35 C6,45 10,50 18,54" />
      <!-- right brace -->
      <path class="ck-line" d="M94,12 L94,35" />
      <path class="ck-line" d="M94,35 C94,45 90,50 82,54" />
      <!-- lower rails -->
      <path class="ck-line" d="M20,70 L5,95" />
      <path class="ck-line" d="M80,70 L95,95" />
    </svg>
    <div class="ck-panel">
      <div class="dial">RDR</div>
      <div class="readout"><span class="tag">ACEL</span><span id="rdAcel">0</span><span class="tag">SPD</span><span id="rdSpd">0</span><span class="tag">TGT</span><span id="rdTgt">—</span></div>
      <div class="dial">SYS</div>
    </div>
  </div>

  <!-- Mobile controls -->
  <div id="mobileControls">
    <div id="joypad">
      <div class="stickBase"></div>
      <div class="stickKnob" id="stick"></div>
    </div>
    <div id="fireBtns">
      <button id="btnLaser" class="fire">LASER</button>
      <button id="btnMissile" class="fire">MISSILE</button>
    </div>
    <div id="tiltChip" class="pill">Tilt: <span id="tiltState">OFF</span></div>
  </div>

  <div id="hint">Move mouse / joystick / tilt to steer • Click/Space = Laser • M = Missile</div>
</div>

<div id="err"></div>

<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
<script>
/*** ==== ERRORS TO SCREEN ==== ***/
window.addEventListener('error', e=>{
  const box=document.getElementById('err'); box.style.display='block';
  box.textContent=(e.error&&e.error.stack)?e.error.stack:(e.message||'Script error');
});

/*** ==== DOM ==== ***/
const canvas=document.getElementById('game');
const scoreEl=document.getElementById('score'), bestEl=document.getElementById('best'), hpEl=document.getElementById('hp');
const btnPause=document.getElementById('btnPause'), btnFull=document.getElementById('btnFull');
const btnLaser=document.getElementById('btnLaser'), btnMissile=document.getElementById('btnMissile');
const btnTilt=document.getElementById('btnTilt'), tiltStateEl=document.getElementById('tiltState');
const stick=document.getElementById('stick'), joypad=document.getElementById('joypad');
const rdAcel=document.getElementById('rdAcel'), rdSpd=document.getElementById('rdSpd'), rdTgt=document.getElementById('rdTgt');

window.started=false; window.paused=false; window._gameStarted=false;
function startGame(e){
  if(e && e.target && e.target.closest && e.target.closest('#startCard a')) return;
  if(window._gameStarted) return;
  window._gameStarted = true; window.started = true; window.paused = false;
  const ov=document.getElementById('startOverlay'); if(ov && ov.parentNode) ov.parentNode.removeChild(ov);
  try{ if(!isTouch) canvas.requestPointerLock?.(); }catch(_){}
  // kick audio context
  audio.start();
}
document.addEventListener('keydown', (e)=>{ if(!window._gameStarted && (e.code==='Enter'||e.code==='Space')) startGame(e); });
document.addEventListener('pointerdown', function once(ev){
  if(window._gameStarted) { document.removeEventListener('pointerdown', once, true); return; }
  if(ev.target && ev.target.closest && ev.target.closest('#startCard a')) return;
  startGame(ev); document.removeEventListener('pointerdown', once, true);
}, true);

/*** ==== AUDIO (WebAudio; no external files) ==== ***/
const audio = (() => {
  let ctx, master;
  function start(){
    if(ctx) return;
    ctx = new (window.AudioContext||window.webkitAudioContext)();
    master = ctx.createGain(); master.gain.value = 0.6; master.connect(ctx.destination);
  }
  function noiseBurst(duration=0.25){
    const buffer = ctx.createBuffer(1, ctx.sampleRate*duration, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]= (Math.random()*2-1) * Math.exp(-6*i/data.length);
    const src = ctx.createBufferSource(); src.buffer=buffer; 
    const filter = ctx.createBiquadFilter(); filter.type='lowpass'; filter.frequency.setValueAtTime(800, ctx.currentTime);
    const gain = ctx.createGain(); gain.gain.value = 0.9;
    src.connect(filter); filter.connect(gain); gain.connect(master);
    src.start();
    // quick pitch drop boom layer
    const osc = ctx.createOscillator(); osc.type='sawtooth';
    const og = ctx.createGain(); og.gain.value=0.4; osc.connect(og); og.connect(master);
    const t=ctx.currentTime;
    osc.frequency.setValueAtTime(180, t);
    osc.frequency.exponentialRampToValueAtTime(60, t+0.25);
    og.gain.setValueAtTime(0.45, t);
    og.gain.exponentialRampToValueAtTime(0.001, t+0.3);
    osc.start(); osc.stop(t+0.32);
    src.stop(t+duration);
  }
  function explosion(){ if(!ctx) return; noiseBurst(0.28); }
  return { start, explosion };
})();

/*** ==== THREE SETUP ==== ***/
const renderer=new THREE.WebGLRenderer({canvas,antialias:true,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.toneMapping=THREE.ACESFilmicToneMapping; renderer.toneMappingExposure=1.05;

const scene=new THREE.Scene();
scene.fog=new THREE.Fog(0x03060c,140,1200);

const world=new THREE.Group(); scene.add(world);

/* Camera: 3rd-person chase */
const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,3000);
const camRig=new THREE.Group(); scene.add(camRig); camRig.add(camera);
camera.position.set(0,3.2,9.5);

/* Lights */
scene.add(new THREE.HemisphereLight(0x88ccff,0x001015,0.9));
const dl=new THREE.DirectionalLight(0xffffff,0.65); dl.position.set(4,8,6); scene.add(dl);

/* Ground grid */
const grid=new THREE.GridHelper(2600,180,0x00ffff,0x00ffff);
grid.material.transparent=true; grid.material.opacity=0.22; world.add(grid);

/* Stars */
const starGeo=new THREE.BufferGeometry(), N=2400, pos=new Float32Array(N*3);
for(let i=0;i<N;i++){ pos[i*3]=(Math.random()-0.5)*320; pos[i*3+1]=Math.random()*180+10; pos[i*3+2]=-Math.random()*1500-80; }
starGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
const stars=new THREE.Points(starGeo,new THREE.PointsMaterial({size:1.0,color:0x99ddff,transparent:true,depthWrite:false,blending:THREE.AdditiveBlending}));
world.add(stars);

/* Speed lines */
const L=540, spdGeo=new THREE.BufferGeometry(), spdPos=new Float32Array(L*6);
function resetLine(i, zoff= -1500*Math.random()-100){
  const x=(Math.random()-0.5)*34, y=Math.random()*10+1.5, z=zoff, len=(Math.random()*6+4);
  spdPos[i*6+0]=x; spdPos[i*6+1]=y; spdPos[i*6+2]=z;
  spdPos[i*6+3]=x; spdPos[i*6+4]=y; spdPos[i*6+5]=z+len;
}
for(let i=0;i<L;i++) resetLine(i, -1500*Math.random()-50);
spdGeo.setAttribute('position', new THREE.BufferAttribute(spdPos,3));
const speedLines=new THREE.LineSegments(spdGeo, new THREE.LineBasicMaterial({ color:0x77e5ff, transparent:true, opacity:0.5 }));
world.add(speedLines);

/*** ==== PLAYER SHIP (visible 3rd person) ==== ***/
const playerShip=new THREE.Group();
(function buildPlayerShip(){
  const bodyMat=new THREE.MeshStandardMaterial({color:0x0bd3ff, metalness:0.1, roughness:0.6});
  const edgeMat=new THREE.LineBasicMaterial({color:0x000000});
  const body=new THREE.Mesh(new THREE.ConeGeometry(0.55,1.4,16), bodyMat);
  body.rotation.x=Math.PI/2; body.position.set(0,0,0.1);
  const tail=new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.35,0.9,12), bodyMat); tail.rotation.x=Math.PI/2; tail.position.set(0,0,-0.6);
  const wingL=new THREE.Mesh(new THREE.BoxGeometry(0.9,0.08,0.28), bodyMat); wingL.position.set(-0.65,-0.05,-0.15);
  const wingR=wingL.clone(); wingR.position.x*=-1;
  const canopy=new THREE.Mesh(new THREE.SphereGeometry(0.22,16,12), new THREE.MeshStandardMaterial({color:0x111111, metalness:0.0, roughness:0.9}));
  canopy.position.set(0,0.1,0.25);
  const edges=new THREE.EdgesGeometry(new THREE.BoxGeometry(0.8,0.3,0.9));
  const outline=new THREE.LineSegments(edges, edgeMat); outline.position.set(0,0,-0.05);
  playerShip.add(body,tail,wingL,wingR,canopy,outline);
})();
scene.add(playerShip);

/*** ==== GAME STATE ==== ***/
const player={
  x:0, y:4.5, z:0, yaw:0, pitch:0,
  hp:100, score:0, best:Number(localStorage.getItem('nsr_best')||0),
  fireCD:0, missileCD:0
};
scoreEl.textContent='0'; bestEl.textContent=player.best; hpEl.textContent=player.hp;

const enemies=[], lasers=[], missiles=[], fx=[];
let gameTime=0;

/*** ==== ENEMIES ==== ***/
const ENEMY_PALETTE=[0xff6d00,0xffd400,0x00ff88,0xff4081,0x66ff00];
function buildEnemy(color){
  const g=new THREE.Group();
  const matBody=new THREE.MeshBasicMaterial({color}); // bright/unlit for contrast
  const body=new THREE.Mesh(new THREE.BoxGeometry(1.4,.36,2.3),matBody);
  const wingL=new THREE.Mesh(new THREE.BoxGeometry(1.2,.1,.6),matBody); wingL.position.set(-1.0,-.08,-.2);
  const wingR=wingL.clone(); wingR.position.x*=-1;
  const nose=new THREE.Mesh(new THREE.ConeGeometry(.34,.9,18),new THREE.MeshBasicMaterial({color:0xffffff})); 
  nose.rotation.x=Math.PI/2; nose.position.set(0,.05,1.35);
  const winMat=new THREE.MeshBasicMaterial({color:0x000000});
  const win1=new THREE.Mesh(new THREE.BoxGeometry(.5,.18,.02),winMat); win1.position.set(0,.18,.4);
  const win2=new THREE.Mesh(new THREE.BoxGeometry(.4,.16,.02),winMat); win2.position.set(0,.16,.1);
  const edges = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.4,.36,2.3));
  const outline = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000}));
  g.add(body,wingL,wingR,nose,win1,win2,outline);
  return g;
}
function difficulty(){
  const t = Math.min(gameTime/120, 1);
  return { enemySpeed: 14+(42-14)*t, spawnMin: 1.4+(0.6-1.4)*t, spawnMax: 1.9+(0.9-1.9)*t };
}
function spawnEnemy(){
  const g=buildEnemy(ENEMY_PALETTE[(Math.random()*ENEMY_PALETTE.length)|0]);
  g.position.set((Math.random()-0.5)*22, Math.random()*8+1.2, -280);
  const d=difficulty();
  g.userData={speed:d.enemySpeed + Math.random()*4, phase:Math.random()*Math.PI*2, hp:3, r:1.25, baseColor:g.children[0].material.color.getHex()};
  world.add(g); enemies.push(g);
}

/*** ==== FX (explosions) ==== ***/
function explodeAt(pos, baseColor=0xffaa33){
  const grp=new THREE.Group(); grp.position.copy(pos);
  const flash=new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:1, blending:THREE.AdditiveBlending}));
  grp.add(flash);
  const debrisMat=new THREE.MeshBasicMaterial({color:baseColor});
  for(let i=0;i<14;i++){
    const d=new THREE.Mesh(new THREE.BoxGeometry(0.12,0.06,0.04), debrisMat);
    d.position.set((Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3,(Math.random()-0.5)*0.3);
    d.userData.v=new THREE.Vector3((Math.random()-0.5)*6,(Math.random()-0.2)*5,(Math.random()-0.5)*6);
    grp.add(d);
  }
  const ring=new THREE.Mesh(new THREE.RingGeometry(0.1,0.12,32), new THREE.MeshBasicMaterial({color:0xffffff, transparent:true, opacity:0.8, side:THREE.DoubleSide, blending:THREE.AdditiveBlending}));
  ring.rotation.x=Math.PI/2; grp.add(ring);

  grp.userData.life=0.8;
  grp.userData.update=(dt)=>{
    grp.userData.life-=dt;
    const t=1-Math.max(0,grp.userData.life)/0.8;
    flash.scale.setScalar(1+3*t); flash.material.opacity=1-t;
    ring.scale.setScalar(1+6*t); ring.material.opacity=0.8*(1-t);
    for(const c of grp.children){ if(c.userData && c.userData.v){ c.position.addScaledVector(c.userData.v,dt); c.userData.v.y -= 6*dt; } }
    return grp.userData.life<=0;
  };
  world.add(grp); fx.push(grp);
  audio.explosion(); // SOUND!
}

/*** ==== WEAPONS (bright lasers, swept collision) ==== ***/
function makeLaser(dir){
  const core=new THREE.Mesh(new THREE.CylinderGeometry(.05,.05,1.4,12), new THREE.MeshBasicMaterial({color:0xb8ffff}));
  core.rotation.x=Math.PI/2;
  const glowMat=new THREE.MeshBasicMaterial({color:0x00ffff}); glowMat.blending=THREE.AdditiveBlending; glowMat.transparent=true; glowMat.opacity=0.9;
  const glow=new THREE.Mesh(new THREE.CylinderGeometry(.18,.18,1.4,16), glowMat); glow.rotation.x=Math.PI/2;
  const beam=new THREE.Group(); beam.add(glow,core);
  beam.userData={v:dir.clone().multiplyScalar(220),life:2.4,r:.32,damage:1,prev:new THREE.Vector3()};
  return beam;
}
function fireLaser(){
  if(player.fireCD>0) return; player.fireCD=.07;
  const dir=new THREE.Vector3(0,0,-1);
  const beam=makeLaser(dir);
  const origin = playerShip.position.clone().add(new THREE.Vector3(0,0.05,0.8));
  beam.position.copy(origin);
  beam.userData.prev.copy(origin);
  world.add(beam); lasers.push(beam);
}
function findNearestEnemy(){
  let best=null, bestD=Infinity, tmp=new THREE.Vector3();
  for(const e of enemies){ tmp.copy(e.position).sub(playerShip.position); const d=tmp.lengthSq(); if(d<bestD){ bestD=d; best=e; } }
  return best;
}
function fireMissile(){
  if(player.missileCD>0) return; player.missileCD=1.0;
  const target=findNearestEnemy();
  const m=new THREE.Mesh(new THREE.CapsuleGeometry(.12,.6,4,8), new THREE.MeshBasicMaterial({color:0xffaa33}));
  m.position.copy(playerShip.position).add(new THREE.Vector3(0,-0.05,0.4));
  m.userData={speed:110, life:3.0, r:.34, damage:3, target};
  world.add(m); missiles.push(m);
}

/*** ==== INPUT ==== ***/
let pointerLocked=false, isTouch=('ontouchstart' in window)||navigator.maxTouchPoints>0;
document.addEventListener('pointerlockchange',()=>{ pointerLocked=(document.pointerLockElement===canvas); });

const keys=new Set();
addEventListener('keydown',e=>{ keys.add(e.code); if(e.code==='Space') fireLaser(); if(e.code==='KeyM') fireMissile(); });
addEventListener('keyup',e=>{ keys.delete(e.code); });

let mouseNX=0, mouseNY=0; // -1..1 (right/up positive)
window.addEventListener('mousemove',e=>{
  const r=document.body.getBoundingClientRect();
  const cx=r.left + r.width/2, cy=r.top + r.height/2;
  mouseNX = (e.clientX-cx)/(r.width/2);
  mouseNY = (cy-e.clientY)/(r.height/2);
  mouseNX = Math.max(-1,Math.min(1,mouseNX));
  mouseNY = Math.max(-1,Math.min(1,mouseNY));
});

// Mobile joystick
const joy = {active:false, base:[0,0], vec:[0,0], maxR:0};
function joyReset(){ joy.active=false; joy.vec=[0,0]; moveStick(0,0); }
function moveStick(nx,ny){ const base=joypad.getBoundingClientRect(); const r=Math.min(base.width,base.height)*0.23; stick.style.transform=`translate(-50%,-50%) translate(${nx*r}px,${-ny*r}px)`; }
function clampVec(x,y){ const m=Math.hypot(x,y)||1; return m>1?[x/m,y/m]:[x,y]; }
joypad.addEventListener('touchstart',e=>{
  const t=e.touches[0]; const rect=joypad.getBoundingClientRect();
  joy.active=true; joy.base=[t.clientX-rect.left, t.clientY-rect.top]; joy.maxR=Math.min(rect.width,rect.height)*0.23;
},{passive:true});
joypad.addEventListener('touchmove',e=>{
  if(!joy.active) return;
  const t=e.touches[0]; const rect=joypad.getBoundingClientRect();
  const dx=(t.clientX-rect.left) - joy.base[0];     // right +
  const dy= joy.base[1] - (t.clientY-rect.top);     // up +
  let nx=dx/joy.maxR, ny=dy/joy.maxR; [nx,ny]=clampVec(nx,ny);
  joy.vec=[nx,ny]; moveStick(nx,ny);
},{passive:true});
joypad.addEventListener('touchend',()=>{ joyReset(); },{passive:true});

btnLaser.addEventListener('touchstart',()=>fireLaser(),{passive:true});
btnMissile.addEventListener('touchstart',()=>fireMissile(),{passive:true});
btnLaser.addEventListener('click',()=>fireLaser());
btnMissile.addEventListener('click',()=>fireMissile());

// Tilt (right=+, up=+)
let tiltEnabled=false, tiltVec={x:0,y:0};
async function enableTilt(){
  try{
    if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      const s=await DeviceMotionEvent.requestPermission(); if(s!=='granted') throw new Error('Motion permission denied');
    }
    if(typeof DeviceOrientationEvent!=='undefined' && typeof DeviceOrientationEvent.requestPermission==='function'){
      const s=await DeviceOrientationEvent.requestPermission(); if(s!=='granted') throw new Error('Orientation permission denied');
    }
    tiltEnabled=true; tiltStateEl.textContent='ON';
  }catch(err){ tiltEnabled=false; tiltStateEl.textContent='DENIED'; console.warn(err); }
}
btnTilt.addEventListener('click',enableTilt);
window.addEventListener('deviceorientation',e=>{
  if(!tiltEnabled) return;
  const gamma=(e.gamma||0), beta=(e.beta||0);
  tiltVec.x = Math.max(-1, Math.min(1, gamma/35));
  tiltVec.y = Math.max(-1, Math.min(1, -beta/50));
});

/*** ==== CONTROLS → FULL-RANGE POSITION (MORE MANEUVERABLE) ==== ***/
const bounds = { x: 13.5, yMin: 0.7, yMax: 10.2 };      // wider & taller area
function updateControl(dt){
  const keyX = (keys.has('KeyA')||keys.has('ArrowLeft') ? -0.9 : 0) + (keys.has('KeyD')||keys.has('ArrowRight') ? +0.9 : 0);
  const keyY = (keys.has('KeyW')||keys.has('ArrowUp') ? +0.9 : 0) + (keys.has('KeyS')||keys.has('ArrowDown') ? -0.9 : 0);
  const jx = joy.vec[0]||0, jy = joy.vec[1]||0;
  const tx = tiltEnabled ? tiltVec.x : 0, ty = tiltEnabled ? tiltVec.y : 0;

  // stronger response
  const wantX = Math.max(-1, Math.min(1, mouseNX*1.0 + jx*1.0 + tx*0.6 + keyX*0.6 ));
  const wantY = Math.max(-1, Math.min(1, mouseNY*1.0 + jy*1.0 + ty*0.6 + keyY*0.6 ));

  const targetX = wantX * bounds.x;
  const targetY = ((wantY + 1)/2) * (bounds.yMax - bounds.yMin) + bounds.yMin;

  // snappier follow
  const follow = 0.28;
  player.x += (targetX - player.x) * follow;
  player.y += (targetY - player.y) * follow;

  // bank & pitch visuals
  playerShip.position.set(player.x, player.y, 0);
  playerShip.rotation.z = -wantX*0.5;
  playerShip.rotation.x = -wantY*0.25;

  // cockpit readouts
  rdAcel.textContent = (Math.hypot(wantX,wantY)*100|0)+'%';
}

/*** ==== LOOP ==== ***/
function resize(){ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); }
addEventListener('resize',resize); resize();

let last=performance.now(), spawnT=0, avgSpd=0;
requestAnimationFrame(function tick(now){
  const dt=Math.min(0.033,(now-last)/1000); last=now;
  if(window.started && !window.paused){
    gameTime+=dt;
    updateControl(dt);
    updateWorld(dt);
  }
  render();
  requestAnimationFrame(tick);
});

/*** ==== WORLD UPDATE ==== ***/
function updateWorld(dt){
  // camera follows player smoothly
  const desired = new THREE.Vector3(player.x*0.85, Math.max(bounds.yMin, player.y-1.2), 9.5);
  camRig.position.lerp(desired, 0.15);
  camera.lookAt(playerShip.position.x, playerShip.position.y+0.2, 0);

  // Spawns
  spawnT-=dt;
  if(spawnT<=0){
    const d=difficulty(); spawnEnemy();
    spawnT = d.spawnMin + Math.random()*(d.spawnMax-d.spawnMin);
  }

  // Enemies
  for(let i=enemies.length-1;i>=0;i--){
    const e=enemies[i];
    e.position.z += e.userData.speed*dt;
    e.position.x += Math.sin(e.userData.phase + performance.now()*0.0013)*0.02;
    // collide ship (sphere)
    const shipR = 0.7;
    if(e.position.distanceTo(playerShip.position) < (e.userData.r + shipR)){
      explodeAt(e.position, 0xff7777);
      enemies.splice(i,1); world.remove(e);
      player.hp = Math.max(0, player.hp-20); hpEl.textContent=player.hp;
      continue;
    }
    if(e.position.z>6){
      enemies.splice(i,1); world.remove(e);
      player.hp = Math.max(0, player.hp-10); hpEl.textContent=player.hp;
    }
  }

  // Lasers — swept segment vs sphere
  for(let i=lasers.length-1;i>=0;i--){
    const l=lasers[i];
    const prev = l.userData.prev.clone();
    l.position.addScaledVector(l.userData.v, dt);
    const curr = l.position.clone();
    l.userData.life-=dt;

    // segment math
    const seg = curr.clone().sub(prev);
    const segLen2 = Math.max(1e-6, seg.lengthSq());

    let hitEnemy = -1;
    for(let j=enemies.length-1;j>=0;j--){
      const e=enemies[j];
      const w = e.position.clone().sub(prev);
      const t = Math.max(0, Math.min(1, w.dot(seg) / segLen2 ));
      const closest = prev.clone().add( seg.clone().multiplyScalar(t) );
      const dist = closest.distanceTo(e.position);
      if(dist < (e.userData.r + l.userData.r)){ e.userData.hp -= l.userData.damage; hitEnemy = j; break; }
    }

    if(hitEnemy>=0){
      const e=enemies[hitEnemy];
      lasers.splice(i,1); world.remove(l);
      if(e.userData.hp<=0){
        explodeAt(e.position, 0xffaa33);       // also triggers sound
        enemies.splice(hitEnemy,1); world.remove(e);
        player.score+=10; scoreEl.textContent=player.score;
      }
      continue;
    }

    if(l.userData.life<=0){ lasers.splice(i,1); world.remove(l); continue; }
    l.userData.prev.copy(curr);
  }

  // Missiles (homing)
  for(let i=missiles.length-1;i>=0;i--){
    const m=missiles[i];
    m.userData.life-=dt; if(m.userData.life<=0){ missiles.splice(i,1); world.remove(m); continue; }
    let dir=new THREE.Vector3(0,0,-1);
    const t=m.userData.target;
    if(t && enemies.includes(t)){
      const seek=t.position.clone().sub(m.position).normalize();
      dir.lerp(seek, 0.2);
    }
    m.position.addScaledVector(dir.normalize(), m.userData.speed*dt);

    let hitIdx=-1;
    for(let j=enemies.length-1;j>=0;j--){
      const e=enemies[j];
      if(m.position.distanceTo(e.position) < (e.userData.r + m.userData.r)){ e.userData.hp -= m.userData.damage; hitIdx=j; break; }
    }
    if(hitIdx>=0){
      const e=enemies[hitIdx];
      missiles.splice(i,1); world.remove(m);
      if(e.userData.hp<=0){
        explodeAt(e.position, 0xffcc55);
        enemies.splice(hitIdx,1); world.remove(e);
        player.score+=15; scoreEl.textContent=player.score;
      }
    }
  }

  // FX
  for(let i=fx.length-1;i>=0;i--){
    const f=fx[i]; if(f.userData.update?.(dt)){ fx.splice(i,1); world.remove(f); }
  }

  // Background motion
  const sp=starGeo.attributes.position;
  for(let i=0;i<sp.count;i++){
    let z=sp.getZ(i)+48*dt; if(z>50) z = -1500- Math.random()*300; sp.setZ(i,z);
  } sp.needsUpdate=true;

  const p=spdGeo.attributes.position;
  for(let i=0;i<p.count/2;i++){
    let z0=p.getZ(i*2)+115*dt, z1=p.getZ(i*2+1)+115*dt;
    if(z0>50){ resetLine(i, -1500); z0=p.getZ(i*2); z1=p.getZ(i*2+1); }
    p.setZ(i*2,z0); p.setZ(i*2+1,z1);
  } p.needsUpdate=true;

  // Cooldowns & death
  player.fireCD=Math.max(0, player.fireCD-dt);
  player.missileCD=Math.max(0, player.missileCD-dt);
  if(player.hp<=0){
    if(player.score>player.best){ player.best=player.score; localStorage.setItem('nsr_best', String(player.best)); }
    location.reload();
  }

  // HUD readouts
  avgSpd = avgSpd*0.9 + (115)*0.1;
  rdSpd.textContent = (avgSpd|0);
  rdTgt.textContent = enemies.length ? 'LOCK' : '—';
}

/*** ==== RENDER ==== ***/
function render(){ renderer.render(scene,camera); }

/*** ==== UI ==== ***/
btnPause.onclick=()=>{ window.paused=!window.paused; };
btnFull.onclick=()=>{ document.fullscreenElement?document.exitFullscreen():document.documentElement.requestFullscreen?.(); };

/*** ==== RESIZE ==== ***/
addEventListener('resize',()=>{ renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); });
</script>
</body>
</html>
